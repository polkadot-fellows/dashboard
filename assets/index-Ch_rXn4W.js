import{v as C,B as h,s as w,a as Ee,b as U,k as Oe,f as G,c as E,d as v,t as g,e as Re,g as j,h as Me,i as ze,j as Be,l as ke,m as je,n as re,p as M,o as ie,I as _e,q as z,r as Ue,u as k}from"./index-BQIVLprL.js";const Te="1.2.3";class f extends Error{constructor(t,n={}){const r=n.cause instanceof f?n.cause.details:n.cause?.message?n.cause.message:n.details,i=n.cause instanceof f&&n.cause.docsPath||n.docsPath,o=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...i?[`Docs: https://abitype.dev${i}`]:[],...r?[`Details: ${r}`]:[],`Version: abitype@${Te}`].join(`
`);super(o),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),n.cause&&(this.cause=n.cause),this.details=r,this.docsPath=i,this.metaMessages=n.metaMessages,this.shortMessage=t}}function $(e,t){return e.exec(t)?.groups}const se=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,oe=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,ae=/^\(.+?\).*?$/,Q=/^tuple(?<array>(\[(\d*)\])*)$/;function N(e){let t=e.type;if(Q.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let i=0;i<n;i++){const o=e.components[i];t+=N(o),i<n-1&&(t+=", ")}const r=$(Q,e.type);return t+=`)${r?.array||""}`,N({...e,type:t})}return"indexed"in e&&e.indexed&&(t=`${t} indexed`),e.name?`${t} ${e.name}`:t}function x(e){let t="";const n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=N(i),r!==n-1&&(t+=", ")}return t}function _(e){return e.type==="function"?`function ${e.name}(${x(e.inputs)})${e.stateMutability&&e.stateMutability!=="nonpayable"?` ${e.stateMutability}`:""}${e.outputs?.length?` returns (${x(e.outputs)})`:""}`:e.type==="event"?`event ${e.name}(${x(e.inputs)})`:e.type==="error"?`error ${e.name}(${x(e.inputs)})`:e.type==="constructor"?`constructor(${x(e.inputs)})${e.stateMutability==="payable"?" payable":""}`:e.type==="fallback"?`fallback() external${e.stateMutability==="payable"?" payable":""}`:"receive() external payable"}const ue=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function Le(e){return ue.test(e)}function Ce(e){return $(ue,e)}const ce=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function Ne(e){return ce.test(e)}function Fe(e){return $(ce,e)}const le=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;function Ve(e){return le.test(e)}function Ze(e){return $(le,e)}const de=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function pe(e){return de.test(e)}function De(e){return $(de,e)}const fe=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;function We(e){return fe.test(e)}function Ke(e){return $(fe,e)}const he=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;function Ge(e){return he.test(e)}function He(e){return $(he,e)}const Je=/^receive\(\) external payable$/;function Ye(e){return Je.test(e)}const qe=new Set(["indexed"]),F=new Set(["calldata","memory","storage"]);class Qe extends f{constructor({signature:t}){super("Failed to parse ABI item.",{details:`parseAbiItem(${JSON.stringify(t,null,2)})`,docsPath:"/api/human#parseabiitem-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiItemError"})}}class Xe extends f{constructor({type:t}){super("Unknown type.",{metaMessages:[`Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class et extends f{constructor({type:t}){super("Unknown type.",{metaMessages:[`Type "${t}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}class tt extends f{constructor({param:t}){super("Invalid ABI parameter.",{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class nt extends f{constructor({param:t,name:n}){super("Invalid ABI parameter.",{details:t,metaMessages:[`"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class rt extends f{constructor({param:t,type:n,modifier:r}){super("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class it extends f{constructor({param:t,type:n,modifier:r}){super("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class st extends f{constructor({abiParameter:t}){super("Invalid ABI parameter.",{details:JSON.stringify(t,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}class O extends f{constructor({signature:t,type:n}){super(`Invalid ${n} signature.`,{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class ot extends f{constructor({signature:t}){super("Unknown signature.",{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class at extends f{constructor({signature:t}){super("Invalid struct signature.",{details:t,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class ut extends f{constructor({type:t}){super("Circular reference detected.",{metaMessages:[`Struct "${t}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class ct extends f{constructor({current:t,depth:n}){super("Unbalanced parentheses.",{metaMessages:[`"${t.trim()}" has too many ${n>0?"opening":"closing"} parentheses.`],details:`Depth "${n}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}function lt(e,t,n){let r="";if(n)for(const i of Object.entries(n)){if(!i)continue;let o="";for(const s of i[1])o+=`[${s.type}${s.name?`:${s.name}`:""}]`;r+=`(${i[0]}{${o}})`}return t?`${t}:${e}${r}`:`${e}${r}`}const L=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);function X(e,t={}){if(Ve(e))return dt(e,t);if(Ne(e))return pt(e,t);if(Le(e))return ft(e,t);if(We(e))return ht(e,t);if(Ge(e))return yt(e);if(Ye(e))return{type:"receive",stateMutability:"payable"};throw new ot({signature:e})}function dt(e,t={}){const n=Ze(e);if(!n)throw new O({signature:e,type:"function"});const r=y(n.parameters),i=[],o=r.length;for(let a=0;a<o;a++)i.push(P(r[a],{modifiers:F,structs:t,type:"function"}));const s=[];if(n.returns){const a=y(n.returns),c=a.length;for(let u=0;u<c;u++)s.push(P(a[u],{modifiers:F,structs:t,type:"function"}))}return{name:n.name,type:"function",stateMutability:n.stateMutability??"nonpayable",inputs:i,outputs:s}}function pt(e,t={}){const n=Fe(e);if(!n)throw new O({signature:e,type:"event"});const r=y(n.parameters),i=[],o=r.length;for(let s=0;s<o;s++)i.push(P(r[s],{modifiers:qe,structs:t,type:"event"}));return{name:n.name,type:"event",inputs:i}}function ft(e,t={}){const n=Ce(e);if(!n)throw new O({signature:e,type:"error"});const r=y(n.parameters),i=[],o=r.length;for(let s=0;s<o;s++)i.push(P(r[s],{structs:t,type:"error"}));return{name:n.name,type:"error",inputs:i}}function ht(e,t={}){const n=Ke(e);if(!n)throw new O({signature:e,type:"constructor"});const r=y(n.parameters),i=[],o=r.length;for(let s=0;s<o;s++)i.push(P(r[s],{structs:t,type:"constructor"}));return{type:"constructor",stateMutability:n.stateMutability??"nonpayable",inputs:i}}function yt(e){const t=He(e);if(!t)throw new O({signature:e,type:"fallback"});return{type:"fallback",stateMutability:t.stateMutability??"nonpayable"}}const mt=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\spayable)?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,bt=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,gt=/^u?int$/;function P(e,t){const n=lt(e,t?.type,t?.structs);if(L.has(n))return L.get(n);const r=ae.test(e),i=$(r?bt:mt,e);if(!i)throw new tt({param:e});if(i.name&&vt(i.name))throw new nt({param:e,name:i.name});const o=i.name?{name:i.name}:{},s=i.modifier==="indexed"?{indexed:!0}:{},a=t?.structs??{};let c,u={};if(r){c="tuple";const d=y(i.type),p=[],m=d.length;for(let b=0;b<m;b++)p.push(P(d[b],{structs:a}));u={components:p}}else if(i.type in a)c="tuple",u={components:a[i.type]};else if(gt.test(i.type))c=`${i.type}256`;else if(i.type==="address payable")c="address";else if(c=i.type,t?.type!=="struct"&&!ye(c))throw new et({type:c});if(i.modifier){if(!t?.modifiers?.has?.(i.modifier))throw new rt({param:e,type:t?.type,modifier:i.modifier});if(F.has(i.modifier)&&!$t(c,!!i.array))throw new it({param:e,type:t?.type,modifier:i.modifier})}const l={type:`${c}${i.array??""}`,...o,...s,...u};return L.set(n,l),l}function y(e,t=[],n="",r=0){const i=e.trim().length;for(let o=0;o<i;o++){const s=e[o],a=e.slice(o+1);switch(s){case",":return r===0?y(a,[...t,n.trim()]):y(a,t,`${n}${s}`,r);case"(":return y(a,t,`${n}${s}`,r+1);case")":return y(a,t,`${n}${s}`,r-1);default:return y(a,t,`${n}${s}`,r)}}if(n==="")return t;if(r!==0)throw new ct({current:n,depth:r});return t.push(n.trim()),t}function ye(e){return e==="address"||e==="bool"||e==="function"||e==="string"||se.test(e)||oe.test(e)}const wt=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;function vt(e){return e==="address"||e==="bool"||e==="function"||e==="string"||e==="tuple"||se.test(e)||oe.test(e)||wt.test(e)}function $t(e,t){return t||e==="bytes"||e==="string"||e==="tuple"}function Pt(e){const t={},n=e.length;for(let s=0;s<n;s++){const a=e[s];if(!pe(a))continue;const c=De(a);if(!c)throw new O({signature:a,type:"struct"});const u=c.properties.split(";"),l=[],d=u.length;for(let p=0;p<d;p++){const b=u[p].trim();if(!b)continue;const R=P(b,{type:"struct"});l.push(R)}if(!l.length)throw new at({signature:a});t[c.name]=l}const r={},i=Object.entries(t),o=i.length;for(let s=0;s<o;s++){const[a,c]=i[s];r[a]=me(c,t)}return r}const At=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function me(e=[],t={},n=new Set){const r=[],i=e.length;for(let o=0;o<i;o++){const s=e[o];if(ae.test(s.type))r.push(s);else{const c=$(At,s.type);if(!c?.type)throw new st({abiParameter:s});const{array:u,type:l}=c;if(l in t){if(n.has(l))throw new ut({type:l});r.push({...s,type:`tuple${u??""}`,components:me(t[l],t,new Set([...n,l]))})}else if(ye(l))r.push(s);else throw new Xe({type:l})}}return r}function ee(e){let t;if(typeof e=="string")t=X(e);else{const n=Pt(e),r=e.length;for(let i=0;i<r;i++){const o=e[i];if(!pe(o)){t=X(o,n);break}}}if(!t)throw new Qe({signature:e});return t}function V(e){let t=!0,n="",r=0,i="",o=!1;for(let s=0;s<e.length;s++){const a=e[s];if(["(",")",","].includes(a)&&(t=!0),a==="("&&r++,a===")"&&r--,!!t){if(r===0){if(a===" "&&["event","function","error",""].includes(i))i="";else if(i+=a,a===")"){o=!0;break}continue}if(a===" "){e[s-1]!==","&&n!==","&&n!==",("&&(n="",t=!1);continue}i+=a,n+=a}}if(!o)throw new h("Unable to normalize signature.");return i}function Z(e,t){const n=typeof e,r=t.type;switch(r){case"address":return C(e,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return r==="tuple"&&"components"in t?Object.values(t.components).every((i,o)=>Z(Object.values(e)[o],i)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)?n==="string"||e instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)?Array.isArray(e)&&e.every(i=>Z(i,{...t,type:r.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function be(e,t,n){for(const r in e){const i=e[r],o=t[r];if(i.type==="tuple"&&o.type==="tuple"&&"components"in i&&"components"in o)return be(i.components,o.components,n[r]);const s=[i.type,o.type];if(s.includes("address")&&s.includes("bytes20")?!0:s.includes("address")&&s.includes("string")?C(n[r],{strict:!1}):s.includes("address")&&s.includes("bytes")?C(n[r],{strict:!1}):!1)return s}}function xt(e,t={}){const{prepare:n=!0}=t,r=Array.isArray(e)||typeof e=="string"?ee(e):e;return{...r,...n?{hash:S(r)}:{}}}function T(e,t,n){const{args:r=[],prepare:i=!0}=n??{},o=Ee(t,{strict:!1}),s=e.filter(u=>o?u.type==="function"||u.type==="error"?ge(u)===U(t,0,4):u.type==="event"?S(u)===t:!1:"name"in u&&u.name===t);if(s.length===0)throw new D({name:t});if(s.length===1)return{...s[0],...i?{hash:S(s[0])}:{}};let a;for(const u of s){if(!("inputs"in u))continue;if(!r||r.length===0){if(!u.inputs||u.inputs.length===0)return{...u,...i?{hash:S(u)}:{}};continue}if(!u.inputs||u.inputs.length===0||u.inputs.length!==r.length)continue;if(r.every((d,p)=>{const m="inputs"in u&&u.inputs[p];return m?Z(d,m):!1})){if(a&&"inputs"in a&&a.inputs){const d=be(u.inputs,a.inputs,r);if(d)throw new It({abiItem:u,type:d[0]},{abiItem:a,type:d[1]})}a=u}}const c=(()=>{if(a)return a;const[u,...l]=s;return{...u,overloads:l}})();if(!c)throw new D({name:t});return{...c,...i?{hash:S(c)}:{}}}function ge(...e){const t=(()=>{if(Array.isArray(e[0])){const[n,r]=e;return T(n,r)}return e[0]})();return U(S(t),0,4)}function St(...e){const t=(()=>{if(Array.isArray(e[0])){const[r,i]=e;return T(r,i)}return e[0]})(),n=typeof t=="string"?t:_(t);return V(n)}function S(...e){const t=(()=>{if(Array.isArray(e[0])){const[n,r]=e;return T(n,r)}return e[0]})();return typeof t!="string"&&"hash"in t&&t.hash?t.hash:Oe(G(St(t)))}class It extends h{constructor(t,n){super("Found ambiguous types in overloaded ABI Items.",{metaMessages:[`\`${t.type}\` in \`${V(_(t.abiItem))}\`, and`,`\`${n.type}\` in \`${V(_(n.abiItem))}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.AmbiguityError"})}}class D extends h{constructor({name:t,data:n,type:r="item"}){const i=t?` with name "${t}"`:n?` with data "${n}"`:"";super(`ABI ${r}${i} not found.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.NotFoundError"})}}class Et extends h{constructor({data:t}){super(`Selector size is invalid. Expected 4 bytes. Received ${w(t)} bytes ("${t}").`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.InvalidSelectorSizeError"})}}const Ot=/^(.*)\[([0-9]*)\]$/,Rt=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,we=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function I(e,t,n){const{checksumAddress:r,staticPosition:i}=n,o=Y(t.type);if(o){const[s,a]=o;return zt(e,{...t,type:a},{checksumAddress:r,length:s,staticPosition:i})}if(t.type==="tuple")return _t(e,t,{checksumAddress:r,staticPosition:i});if(t.type==="address")return Mt(e,{checksum:r});if(t.type==="bool")return Bt(e);if(t.type.startsWith("bytes"))return kt(e,t,{staticPosition:i});if(t.type.startsWith("uint")||t.type.startsWith("int"))return jt(e,t);if(t.type==="string")return Ut(e,{staticPosition:i});throw new q(t.type)}const te=32,W=32;function Mt(e,t={}){const{checksum:n=!1}=t,r=e.readBytes(32);return[(o=>n?Re(o):o)(j(Me(r,-20))),32]}function zt(e,t,n){const{checksumAddress:r,length:i,staticPosition:o}=n;if(!i){const c=g(e.readBytes(W)),u=o+c,l=u+te;e.setPosition(u);const d=g(e.readBytes(te)),p=B(t);let m=0;const b=[];for(let R=0;R<d;++R){e.setPosition(l+(p?R*32:m));const[Se,Ie]=I(e,t,{checksumAddress:r,staticPosition:l});m+=Ie,b.push(Se)}return e.setPosition(o+32),[b,32]}if(B(t)){const c=g(e.readBytes(W)),u=o+c,l=[];for(let d=0;d<i;++d){e.setPosition(u+d*32);const[p]=I(e,t,{checksumAddress:r,staticPosition:u});l.push(p)}return e.setPosition(o+32),[l,32]}let s=0;const a=[];for(let c=0;c<i;++c){const[u,l]=I(e,t,{checksumAddress:r,staticPosition:o+s});s+=l,a.push(u)}return[a,s]}function Bt(e){return[ze(e.readBytes(32),{size:32}),32]}function kt(e,t,{staticPosition:n}){const[r,i]=t.type.split("bytes");if(!i){const s=g(e.readBytes(32));e.setPosition(n+s);const a=g(e.readBytes(32));if(a===0)return e.setPosition(n+32),["0x",32];const c=e.readBytes(a);return e.setPosition(n+32),[j(c),32]}return[j(e.readBytes(Number.parseInt(i,10),32)),32]}function jt(e,t){const n=t.type.startsWith("int"),r=Number.parseInt(t.type.split("int")[1]||"256",10),i=e.readBytes(32);return[r>48?Be(i,{signed:n}):g(i,{signed:n}),32]}function _t(e,t,n){const{checksumAddress:r,staticPosition:i}=n,o=t.components.length===0||t.components.some(({name:c})=>!c),s=o?[]:{};let a=0;if(B(t)){const c=g(e.readBytes(W)),u=i+c;for(let l=0;l<t.components.length;++l){const d=t.components[l];e.setPosition(u+a);const[p,m]=I(e,d,{checksumAddress:r,staticPosition:u});a+=m,s[o?l:d?.name]=p}return e.setPosition(i+32),[s,32]}for(let c=0;c<t.components.length;++c){const u=t.components[c],[l,d]=I(e,u,{checksumAddress:r,staticPosition:i});s[o?c:u?.name]=l,a+=d}return[s,a]}function Ut(e,{staticPosition:t}){const n=g(e.readBytes(32)),r=t+n;e.setPosition(r);const i=g(e.readBytes(32));if(i===0)return e.setPosition(t+32),["",32];const o=e.readBytes(i,32),s=ke(je(o));return e.setPosition(t+32),[s,32]}function Tt({checksumAddress:e,parameters:t,values:n}){const r=[];for(let i=0;i<t.length;i++)r.push(H({checksumAddress:e,parameter:t[i],value:n[i]}));return r}function H({checksumAddress:e=!1,parameter:t,value:n}){const r=t,i=Y(r.type);if(i){const[o,s]=i;return Ct(n,{checksumAddress:e,length:o,parameter:{...r,type:s}})}if(r.type==="tuple")return Dt(n,{checksumAddress:e,parameter:r});if(r.type==="address")return Lt(n,{checksum:e});if(r.type==="bool")return Ft(n);if(r.type.startsWith("uint")||r.type.startsWith("int")){const o=r.type.startsWith("int"),[,,s="256"]=we.exec(r.type)??[];return Vt(n,{signed:o,size:Number(s)})}if(r.type.startsWith("bytes"))return Nt(n,{type:r.type});if(r.type==="string")return Zt(n);throw new q(r.type)}function J(e){let t=0;for(let o=0;o<e.length;o++){const{dynamic:s,encoded:a}=e[o];s?t+=32:t+=w(a)}const n=[],r=[];let i=0;for(let o=0;o<e.length;o++){const{dynamic:s,encoded:a}=e[o];s?(n.push(E(t+i,{size:32})),r.push(a),i+=w(a)):n.push(a)}return v(...n,...r)}function Lt(e,t){const{checksum:n=!1}=t;return re(e,{strict:n}),{dynamic:!1,encoded:M(e.toLowerCase())}}function Ct(e,t){const{checksumAddress:n,length:r,parameter:i}=t,o=r===null;if(!Array.isArray(e))throw new Qt(e);if(!o&&e.length!==r)throw new qt({expectedLength:r,givenLength:e.length,type:`${i.type}[${r}]`});let s=!1;const a=[];for(let c=0;c<e.length;c++){const u=H({checksumAddress:n,parameter:i,value:e[c]});u.dynamic&&(s=!0),a.push(u)}if(o||s){const c=J(a);if(o){const u=E(a.length,{size:32});return{dynamic:!0,encoded:a.length>0?v(u,c):u}}if(s)return{dynamic:!0,encoded:c}}return{dynamic:!1,encoded:v(...a.map(({encoded:c})=>c))}}function Nt(e,{type:t}){const[,n]=t.split("bytes"),r=w(e);if(!n){let i=e;return r%32!==0&&(i=z(i,Math.ceil((e.length-2)/2/32)*32)),{dynamic:!0,encoded:v(M(E(r,{size:32})),i)}}if(r!==Number.parseInt(n,10))throw new Pe({expectedSize:Number.parseInt(n,10),value:e});return{dynamic:!1,encoded:z(e)}}function Ft(e){if(typeof e!="boolean")throw new h(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:M(ie(e))}}function Vt(e,{signed:t,size:n}){if(typeof n=="number"){const r=2n**(BigInt(n)-(t?1n:0n))-1n,i=t?-r-1n:0n;if(e>r||e<i)throw new _e({max:r.toString(),min:i.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:E(e,{size:32,signed:t})}}function Zt(e){const t=G(e),n=Math.ceil(w(t)/32),r=[];for(let i=0;i<n;i++)r.push(z(U(t,i*32,(i+1)*32)));return{dynamic:!0,encoded:v(z(E(w(t),{size:32})),...r)}}function Dt(e,t){const{checksumAddress:n,parameter:r}=t;let i=!1;const o=[];for(let s=0;s<r.components.length;s++){const a=r.components[s],c=Array.isArray(e)?s:a.name,u=H({checksumAddress:n,parameter:a,value:e[c]});o.push(u),u.dynamic&&(i=!0)}return{dynamic:i,encoded:i?J(o):v(...o.map(({encoded:s})=>s))}}function Y(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}function B(e){const{type:t}=e;if(t==="string"||t==="bytes"||t.endsWith("[]"))return!0;if(t==="tuple")return e.components?.some(B);const n=Y(e.type);return!!(n&&B({...e,type:n[1]}))}const Wt={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new Ht({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new Gt({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new ne({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new ne({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,e&255),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function Kt(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(Wt);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}class ne extends h{constructor({offset:t}){super(`Offset \`${t}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.NegativeOffsetError"})}}class Gt extends h{constructor({length:t,position:n}){super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.PositionOutOfBoundsError"})}}class Ht extends h{constructor({count:t,limit:n}){super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.RecursiveReadLimitExceededError"})}}function ve(e,t,n={}){const{as:r="Array",checksumAddress:i=!1}=n,o=typeof t=="string"?Ue(t):t,s=Kt(o);if(k(o)===0&&e.length>0)throw new Yt;if(k(o)&&k(o)<32)throw new Jt({data:typeof t=="string"?t:j(t),parameters:e,size:k(o)});let a=0;const c=r==="Array"?[]:{};for(let u=0;u<e.length;++u){const l=e[u];s.setPosition(a);const[d,p]=I(s,l,{checksumAddress:i,staticPosition:0});a+=p,r==="Array"?c.push(d):c[l.name??u]=d}return c}function $e(e,t,n){const{checksumAddress:r=!1}={};if(e.length!==t.length)throw new Ae({expectedLength:e.length,givenLength:t.length});const i=Tt({checksumAddress:r,parameters:e,values:t}),o=J(i);return o.length===0?"0x":o}function K(e,t){if(e.length!==t.length)throw new Ae({expectedLength:e.length,givenLength:t.length});const n=[];for(let r=0;r<e.length;r++){const i=e[r],o=t[r];n.push(K.encode(i,o))}return v(...n)}(function(e){function t(n,r,i=!1){if(n==="address"){const c=r;return re(c),M(c.toLowerCase(),i?32:0)}if(n==="string")return G(r);if(n==="bytes")return r;if(n==="bool")return M(ie(r),i?32:1);const o=n.match(we);if(o){const[c,u,l="256"]=o,d=Number.parseInt(l,10)/8;return E(r,{size:i?32:d,signed:u==="int"})}const s=n.match(Rt);if(s){const[c,u]=s;if(Number.parseInt(u,10)!==(r.length-2)/2)throw new Pe({expectedSize:Number.parseInt(u,10),value:r});return z(r,i?32:0)}const a=n.match(Ot);if(a&&Array.isArray(r)){const[c,u]=a,l=[];for(let d=0;d<r.length;d++)l.push(t(u,r[d],!0));return l.length===0?"0x":v(...l)}throw new q(n)}e.encode=t})(K||(K={}));class Jt extends h{constructor({data:t,parameters:n,size:r}){super(`Data size of ${r} bytes is too small for given parameters.`,{metaMessages:[`Params: (${x(n)})`,`Data:   ${t} (${r} bytes)`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.DataSizeTooSmallError"})}}class Yt extends h{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.'),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ZeroDataError"})}}class qt extends h{constructor({expectedLength:t,givenLength:n,type:r}){super(`Array length mismatch for type \`${r}\`. Expected: \`${t}\`. Given: \`${n}\`.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ArrayLengthMismatchError"})}}class Pe extends h{constructor({expectedSize:t,value:n}){super(`Size of bytes "${n}" (bytes${w(n)}) does not match expected size (bytes${t}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.BytesSizeMismatchError"})}}class Ae extends h{constructor({expectedLength:t,givenLength:n}){super(["ABI encoding parameters/values length mismatch.",`Expected length (parameters): ${t}`,`Given length (values): ${n}`].join(`
`)),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.LengthMismatchError"})}}class Qt extends h{constructor(t){super(`Value \`${t}\` is not a valid array.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidArrayError"})}}class q extends h{constructor(t){super(`Type \`${t}\` is not a valid ABI Type.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidTypeError"})}}function Xt(...e){const[t,n]=(()=>{if(Array.isArray(e[0])){const[o,s,a]=e;return[A(o,s),a]}return e})(),{overloads:r}=t;if(w(n)<4)throw new Et({data:n});if(t.inputs?.length===0)return;const i=r?A([t,...r],n):t;if(!(w(n)<=4))return ve(i.inputs,U(n,4))}function en(...e){const[t,n,r={}]=(()=>{if(Array.isArray(e[0])){const[o,s,a,c]=e;return[A(o,s),a,c]}return e})(),i=ve(t.outputs,n,r);if(!(i&&Object.keys(i).length===0))return i&&Object.keys(i).length===1?Array.isArray(i)?i[0]:Object.values(i)[0]:i}function tn(...e){const[t,n=[]]=(()=>{if(Array.isArray(e[0])){const[u,l,d]=e;return[A(u,l,{args:d}),d]}const[a,c]=e;return[a,c]})(),{overloads:r}=t,i=r?A([t,...r],t.name,{args:n}):t,o=xe(i),s=n.length>0?$e(i.inputs,n):void 0;return s?v(o,s):o}function nn(...e){const[t,n,r={}]=(()=>{if(Array.isArray(e[0])){const[s,a,c,u]=e;return[A(s,a),c,u]}return e})(),{as:i="Array"}=r,o=t.outputs.length===1?[n]:Array.isArray(n)?n:i==="Object"?Object.values(n):[n];return $e(t.outputs,o)}function rn(e){return _(e)}function sn(e,t={}){return xt(e,t)}function A(e,t,n){const r=T(e,t,n);if(r.type!=="function")throw new D({name:t,type:"function"});return r}function xe(e){return ge(e)}const an=Object.freeze(Object.defineProperty({__proto__:null,decodeData:Xt,decodeResult:en,encodeData:tn,encodeResult:nn,format:rn,from:sn,fromAbi:A,getSelector:xe},Symbol.toStringTag,{value:"Module"}));export{an as AbiFunction};
