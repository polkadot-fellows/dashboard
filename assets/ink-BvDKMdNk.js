import{w as M,V as $,x as w,S as g,y as H,_ as y,z as h,T as z,A as N,C as V,O as T,D as B,E,F as L,G as q,H as A,J as D,K}from"./index-BYfXACgR.js";const P=e=>{const{metadata:s}=e,n=M(e),r=(t="")=>{const i=e.storage[t];if(!i)throw new Error(`Storage entry ${t||"{root}"} not found`);const l=i.key==null?y:n(i.key);return{key:j(l,i.keyPrefix),value:n(i.typeId)}},a=t=>{const i=g(Object.fromEntries(t.args.map(l=>[l.label,n(l.type.type)])));return{call:j(i,t.selector),value:n(t.returnType.type)}},f=t=>{const i=s.spec.constructors.find(l=>l.label===t);if(!i)throw new Error(`Constructor ${t} not found`);return a(i)},o=t=>{const i=s.spec.messages.find(l=>l.label===t);if(!i)throw new Error(`Message ${t} not found`);return a(i)},d=t=>g(Object.fromEntries(t.args.map(i=>[i.label,n(i.type.type)])));return{buildConstructor:f,buildMessage:o,buildStorage:r,buildEvents:()=>$(Object.fromEntries(s.spec.events.map(t=>[t.label,d(t)]))),buildEvent:t=>{const i=s.spec.events,l=(p,m)=>w(p,b=>b.value,b=>({type:m,value:b}));if(t){const p=i.find(m=>m.signature_topic===t);return p?l(d(p),p.label):null}const v=i.filter(p=>p.signature_topic===t);return v.length?U(v.map(p=>l(d(p),p.label))):null}}},j=(e,s)=>{const n=h.fromHex(s).asBytes(),r=z(N(n.length),e);return w(r,a=>[n,a],([,a])=>a)},U=e=>H(s=>{for(const n of e)try{n.enc(s)}catch{}throw new Error("Unable to encode")},s=>{for(const n of e)try{n.dec(s)}catch{}throw new Error("Unable to decode")}),_=e=>w(L(e),s=>{if(typeof s=="string")return{tag:s,value:void 0};const[n,r]=Object.entries(s)[0];return{tag:n,value:r}},s=>({[s.tag]:s.value})),C=(e,s)=>w(V(e,s),n=>n??[],n=>n),x=T(B),k=C(B),F=_({bool:y,char:y,str:y,u8:y,u16:y,u32:y,u64:y,u128:y,u256:y,i8:y,i16:y,i32:y,i64:y,i128:y,i256:y}),O=C(g({name:x,type:E,typeName:x,docs:k})),G=g({len:q,type:E}),J=g({bitStoreType:E,bitOrderType:E}),R=C(g({name:B,fields:O,index:A,docs:k})),Q=_({composite:g({fields:O}),variant:g({variants:R}),sequence:g({type:E}),array:G,tuple:V(E),primitive:F,compact:g({type:E}),bitSequence:J}),W=g({name:B,type:T(E)}),X=C(W),Y=g({id:E,path:k,params:X,def:Q,docs:k}),Z=w(Y,e=>({id:e.id,path:e.type.path,params:e.type.params??[],def:e.type.def,docs:[]}),e=>({id:e.id,type:{def:e.def,path:e.path,params:e.params}})),tt=C(Z),et=e=>{const s=tt.enc(e.types),n=D.dec(s),r=e.spec.environment.accountId.type,a=n.find(d=>d.id===r);a&&(a.path=["AccountId32"]);const f=nt(e,n),o=K(n);return Object.assign(o,{metadata:e,lookup:n,storage:f})};function nt(e,s){const n={},r=(a,f=[])=>{function o(u){const c=s.length;return s[c]={id:c,docs:[],def:u,params:[],path:[]},c}if("root"in a){const u=Number(e.version)===4?h.fromBytes(h.fromHex(a.root.root_key).asBytes().reverse()).asHex():a.root.root_key,c=r(a.root.layout,f);if(a.root.ty!=null){let t=function(i,l){const v=e.types[i].type,p="composite"in v.def?new Map((v.def.composite.fields??[]).map(b=>[b.name,b.type])):null,m=new Map((v.params??[]).map(b=>[b.name,b.type]));if(m.size===2&&m.has("V")&&p&&p.size===2&&p.has("len")&&p.has("elements")){t(p.get("len"),[...l,"len"]),t(p.get("elements"),l);return}else m.size===3&&m.has("K")&&m.has("V")?n[l.join(".")]={keyPrefix:u,key:m.get("K"),typeId:m.get("V")}:m.size===2&&m.has("V")&&(n[l.join(".")]={keyPrefix:u,key:null,typeId:m.get("V")})};t(a.root.ty,f)}return n[f.join(".")]||(n[f.join(".")]={keyPrefix:u,key:null,typeId:c}),o({tag:"composite",value:[]})}if("leaf"in a)return a.leaf.ty;if("hash"in a)throw new Error("HashLayout not implemented");if("array"in a){const u=r(a.array.layout,f);return u==null?null:o({tag:"array",value:{len:a.array.len,type:u}})}if("struct"in a){const u=a.struct.fields.map(c=>({name:c.name,type:r(c.layout,[...f,c.name]),typeName:void 0,docs:[]})).filter(c=>c.type!=null);return o({tag:"composite",value:u})}const d=Object.values(a.enum.variants).map((u,c)=>({name:u.name,fields:u.fields.map(t=>({name:t.name,type:r(t.layout,[...f,u.name,t.name]),typeName:void 0,docs:[]})).filter(t=>t.type!==null),index:c,docs:[]}));return o({tag:"variant",value:d})};return r(e.storage),n}const ct=e=>{if(!e.metadata)throw new Error("Ink client needs the contract metadata");const s=et(e.metadata),n=P(s),r=S(n.buildConstructor),a=S(n.buildMessage),f=c=>{const t=s.metadata.spec.constructors.find(i=>i.label===c);if(!t)throw new Error(`Constructor ${c} not found`);return t},o=c=>{const t=s.metadata.spec.messages.find(i=>i.label===c);if(!t)throw new Error(`Message ${c} not found`);return t},d=s.metadata.spec.constructors.find(c=>c.default)?.label,u=s.metadata.spec.messages.find(c=>c.default)?.label;return{constructor:c=>({attributes:I(f(c)),...r(c)}),defaultConstructor:d,message:c=>({attributes:I(o(c)),...a(c)}),defaultMessage:u,storage:st(n.buildStorage),event:Number(s.metadata.version)===4?ot(n.buildEvents):rt(s,n.buildEvent)}},I=e=>({payable:e.payable,default:e.default,mutates:"mutates"in e?e.mutates:!0}),S=e=>s=>{const n=e(s);return{encode:r=>h.fromBytes(n.call.enc(r||{})),decode:r=>n.value.dec(r.data.asBytes())}},st=e=>s=>{const n=e(s);return{encode:r=>h.fromBytes(n.key.enc(r)),decode:r=>n.value.dec(r.asBytes())}},ot=e=>{const s=r=>e().dec(r.data.asBytes());return{decode:s,filter:(r,a=[])=>a.map(o=>"event"in o?o.event:o).filter(o=>o.type==="Contracts"&&o.value.type==="ContractEmitted"&&o.value.value.contract===r).map(o=>{try{return s(o.value.value)}catch(d){throw console.error(`Contract ${r} emitted an incompatible event`,o.value.value),d}})}},rt=(e,s)=>{const n=new Set(e.metadata.spec.events.map(o=>o.signature_topic).filter(o=>o!=null)),r=e.metadata.spec.events.some(o=>o.signature_topic==null),a=(o,d)=>{if(d!=null){if(!n.has(d))throw new Error(`Event with signature topic ${o} not found`);return s(d).dec(o.data.asBytes())}if(!r)throw new Error("Event signature topic required");return s(void 0).dec(o.data.asBytes())};return{decode:a,filter:(o,d=[])=>{const u=t=>(typeof t=="string"?t:t.asHex())===o;return d.map(t=>"event"in t?t:{event:t,topics:t.topics}).filter(t=>(t.event.type==="Contracts"||t.event.type==="Revive")&&t.event.value.type==="ContractEmitted"&&u(t.event.value.value.contract)).map(t=>{const l=[...t.topics,...t.event.value?.value?.topics??[]].map(v=>v.asHex()).find(v=>n.has(v));try{return a(t.event.value.value,l)}catch{return null}}).filter(t=>t!==null)}}};export{ct as getInkClient};
