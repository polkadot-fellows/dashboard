import{w as $,V as H,x as w,S as g,y as z,_ as y,z as h,T as N,A as L,C as T,O as _,D as B,E,F as q,G as A,H as D,J as K,K as P}from"./index-DhhTP0fW.js";const U=e=>{const{metadata:s}=e,n=$(e),r=(t="")=>{const i=e.storage[t];if(!i)throw new Error(`Storage entry ${t||"{root}"} not found`);const l=i.key==null?y:n(i.key);return{key:I(l,i.keyPrefix),value:n(i.typeId)}},a=t=>{const i=g(Object.fromEntries(t.args.map(l=>[l.label,n(l.type.type)])));return{call:I(i,t.selector),value:n(t.returnType.type)}},f=t=>{const i=s.spec.constructors.find(l=>l.label===t);if(!i)throw new Error(`Constructor ${t} not found`);return a(i)},o=t=>{const i=s.spec.messages.find(l=>l.label===t);if(!i)throw new Error(`Message ${t} not found`);return a(i)},d=t=>g(Object.fromEntries(t.args.map(i=>[i.label,n(i.type.type)])));return{buildConstructor:f,buildMessage:o,buildStorage:r,buildEvents:()=>H(Object.fromEntries(s.spec.events.map(t=>[t.label,d(t)]))),buildEvent:t=>{const i=s.spec.events,l=(p,m)=>w(p,b=>b.value,b=>({type:m,value:b}));if(t){const p=i.find(m=>m.signature_topic===t);return p?l(d(p),p.label):null}const v=i.filter(p=>p.signature_topic===t);return v.length?F(v.map(p=>l(d(p),p.label))):null}}},I=(e,s)=>{const n=h.fromHex(s).asBytes(),r=N(L(n.length),e);return w(r,a=>[n,a],([,a])=>a)},F=e=>z(s=>{for(const n of e)try{n.enc(s)}catch{}throw new Error("Unable to encode")},s=>{for(const n of e)try{n.dec(s)}catch{}throw new Error("Unable to decode")}),M=e=>w(q(e),s=>{if(typeof s=="string")return{tag:s,value:void 0};const[n,r]=Object.entries(s)[0];return{tag:n,value:r}},s=>({[s.tag]:s.value})),C=(e,s)=>w(T(e,s),n=>n??[],n=>n),j=_(B),k=C(B),G=M({bool:y,char:y,str:y,u8:y,u16:y,u32:y,u64:y,u128:y,u256:y,i8:y,i16:y,i32:y,i64:y,i128:y,i256:y}),O=C(g({name:j,type:E,typeName:j,docs:k})),J=g({len:A,type:E}),R=g({bitStoreType:E,bitOrderType:E}),W=C(g({name:B,fields:O,index:D,docs:k})),Q=M({composite:g({fields:O}),variant:g({variants:W}),sequence:g({type:E}),array:J,tuple:T(E),primitive:G,compact:g({type:E}),bitSequence:R}),X=g({name:B,type:_(E)}),Y=C(X),Z=g({id:E,path:k,params:Y,def:Q,docs:k}),tt=w(Z,e=>({id:e.id,path:e.type.path,params:e.type.params??[],def:e.type.def,docs:[]}),e=>({id:e.id,type:{def:e.def,path:e.path,params:e.params}})),et=C(tt),nt=e=>{const s=et.enc(e.types),n=K.dec(s),r=e.spec.environment.accountId.type,a=n.find(d=>d.id===r);a&&(a.path=["AccountId32"]);const f=st(e,n),o=P(n);return Object.assign(o,{metadata:e,lookup:n,storage:f})};function st(e,s){const n={},r=(a,f=[])=>{function o(u){const c=s.length;return s[c]={id:c,docs:[],def:u,params:[],path:[]},c}if("root"in a){const u=Number(e.version)===4?h.fromBytes(h.fromHex(a.root.root_key).asBytes().reverse()).asHex():a.root.root_key,c=r(a.root.layout,f);if(a.root.ty!=null){let t=function(i,l){const v=e.types[i].type,p="composite"in v.def?new Map((v.def.composite.fields??[]).map(b=>[b.name,b.type])):null,m=new Map((v.params??[]).map(b=>[b.name,b.type]));if(m.size===2&&m.has("V")&&p&&p.size===2&&p.has("len")&&p.has("elements")){t(p.get("len"),[...l,"len"]),t(p.get("elements"),l);return}else m.size===3&&m.has("K")&&m.has("V")?n[l.join(".")]={keyPrefix:u,key:m.get("K"),typeId:m.get("V")}:m.size===2&&m.has("V")&&(n[l.join(".")]={keyPrefix:u,key:null,typeId:m.get("V")})};t(a.root.ty,f)}return n[f.join(".")]||(n[f.join(".")]={keyPrefix:u,key:null,typeId:c}),o({tag:"composite",value:[]})}if("leaf"in a)return a.leaf.ty;if("hash"in a)throw new Error("HashLayout not implemented");if("array"in a){const u=r(a.array.layout,f);return u==null?null:o({tag:"array",value:{len:a.array.len,type:u}})}if("struct"in a){const u=a.struct.fields.map(c=>({name:c.name,type:r(c.layout,[...f,c.name]),typeName:void 0,docs:[]})).filter(c=>c.type!=null);return o({tag:"composite",value:u})}const d=Object.values(a.enum.variants).map((u,c)=>({name:u.name,fields:u.fields.map(t=>({name:t.name,type:r(t.layout,[...f,u.name,t.name]),typeName:void 0,docs:[]})).filter(t=>t.type!==null),index:c,docs:[]}));return o({tag:"variant",value:d})};return r(e.storage),n}const ot=e=>{if(!e.metadata)throw new Error("Ink client needs the contract metadata");const s=nt(e.metadata),n=U(s),r=V(n.buildConstructor),a=V(n.buildMessage),f=c=>{const t=s.metadata.spec.constructors.find(i=>i.label===c);if(!t)throw new Error(`Constructor ${c} not found`);return t},o=c=>{const t=s.metadata.spec.messages.find(i=>i.label===c);if(!t)throw new Error(`Message ${c} not found`);return t},d=s.metadata.spec.constructors.find(c=>c.default)?.label,u=s.metadata.spec.messages.find(c=>c.default)?.label;return{constructor:c=>({attributes:S(f(c)),...r(c)}),defaultConstructor:d,message:c=>({attributes:S(o(c)),...a(c)}),defaultMessage:u,storage:rt(n.buildStorage),event:Number(s.metadata.version)===4?at(n.buildEvents):ct(s,n.buildEvent)}},x=new WeakMap,ut=e=>{const s=x.get(e);if(s)return s;const n=ot(e);return x.set(e,n),n},S=e=>({payable:e.payable,default:e.default,mutates:"mutates"in e?e.mutates:!0}),V=e=>s=>{const n=e(s);return{encode:r=>h.fromBytes(n.call.enc(r||{})),decode:r=>n.value.dec(r.data.asBytes())}},rt=e=>s=>{const n=e(s);return{encode:r=>h.fromBytes(n.key.enc(r)),decode:r=>n.value.dec(r.asBytes())}},at=e=>{const s=r=>e().dec(r.data.asBytes());return{decode:s,filter:(r,a=[])=>a.map(o=>"event"in o?o.event:o).filter(o=>o.type==="Contracts"&&o.value.type==="ContractEmitted"&&o.value.value.contract===r).map(o=>{try{return s(o.value.value)}catch(d){throw console.error(`Contract ${r} emitted an incompatible event`,o.value.value),d}})}},ct=(e,s)=>{const n=new Set(e.metadata.spec.events.map(o=>o.signature_topic).filter(o=>o!=null)),r=e.metadata.spec.events.some(o=>o.signature_topic==null),a=(o,d)=>{if(d!=null){if(!n.has(d))throw new Error(`Event with signature topic ${o} not found`);return s(d).dec(o.data.asBytes())}if(!r)throw new Error("Event signature topic required");return s(void 0).dec(o.data.asBytes())};return{decode:a,filter:(o,d=[])=>{const u=t=>(typeof t=="string"?t:t.asHex())===o;return d.map(t=>"event"in t?t:{event:t,topics:t.topics}).filter(t=>(t.event.type==="Contracts"||t.event.type==="Revive")&&t.event.value.type==="ContractEmitted"&&u(t.event.value.value.contract)).map(t=>{const l=[...t.topics,...t.event.value?.value?.topics??[]].map(v=>v.asHex()).find(v=>n.has(v));try{return a(t.event.value.value,l)}catch{return null}}).filter(t=>t!==null)}}};export{ut as getInkClient};
