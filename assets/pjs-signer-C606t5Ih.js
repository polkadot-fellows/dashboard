import{L as d,S as T,M,N as j,G as S,O as C,A,P as y,Q as H,R as I,U as O,W as v,X as V}from"./index-BA-Ty1AZ.js";const g=(e,n)=>{let t=e.toString(16);t=(t.length%2?"0":"")+t;const s=Math.max(0,(n||0)-t.length/2);return"0x"+"00".repeat(s)+t},B=({additionalSigned:e})=>({genesisHash:d(e)}),_=({value:e})=>({nonce:g(j.dec(e),4)}),W=({additionalSigned:e})=>({transactionVersion:g(S.dec(e),4)}),N=T({tip:j,asset:C(A(1/0))}).dec,R=({value:e})=>{const{tip:n,asset:t}=N(e);return{...t?{assetId:d(t)}:{},tip:g(n,16)}},$=({value:e})=>({tip:g(M.dec(e),16)}),G=({value:e,additionalSigned:n},t)=>({era:d(e),blockHash:d(n),blockNumber:g(t,4)}),K=({additionalSigned:e})=>({specVersion:g(S.dec(e),4)}),U=({value:e,additionalSigned:n})=>e.length&&e[0]?{mode:1,metadataHash:d(n.length?n.slice(1):n)}:{},P=Object.freeze(Object.defineProperty({__proto__:null,ChargeAssetTxPayment:R,ChargeTransactionPayment:$,CheckGenesis:B,CheckMetadataHash:U,CheckMortality:G,CheckNonce:_,CheckSpecVersion:K,CheckTxVersion:W},Symbol.toStringTag,{value:"Module"})),z=H().enc,F=e=>e.startsWith("0x")?y(e):z(e);function J(e,n,t){const s=r=>t({address:e,data:d(r),type:"bytes"}).then(({signature:a})=>y(a)),p=F(e);return{publicKey:p,signTx:async(r,a,l,b,i=I)=>{const o=O(v(l)),c={};c.signedExtensions=[];const{version:f}=o.extrinsic,m=[];o.extrinsic.signedExtensions.map(({identifier:u})=>{const h=a[u];if(!h)throw new Error(`Missing ${u} signed-extension`);if(m.push(h.value),c.signedExtensions.push(u),!P[u]){if(h.value.length===0&&h.additionalSigned.length===0)return;throw new Error(`PJS does not support this signed-extension: ${u}`)}Object.assign(c,P[u](h,b))});const k=f.includes(4)?4:null;if(k==null)throw new Error("Only extrinsic v4 is supported");c.address=e,c.method=d(r),c.version=k,c.withSignedTransaction=!0;const E=await n(c),x=E.signedTransaction;return x?typeof x=="string"?y(x):x:V(o,p,y(E.signature),m,r)},signBytes:s}}const L=new Set(["ed25519","sr25519","ecdsa","ethereum"]),X=async(e,n)=>{let t=window.injectedWeb3?.[e];if(!t)throw new Error(`Unavailable extension: "${e}"`);const s=await t.enable(n),p=s.signer.signPayload.bind(s.signer),w=s.signer.signRaw.bind(s.signer),r=i=>i.filter(({type:o})=>L.has(o)).map(o=>{const c=J(o.address,p,w);return{...o,polkadotSigner:c}});let a=r(await s.accounts.get());const l=new Set,b=s.accounts.subscribe(i=>{a=r(i),l.forEach(o=>{o(a)})});return{name:e,getAccounts:()=>a,subscribe:i=>(l.add(i),()=>{l.delete(i)}),disconnect:()=>{b()}}},q=()=>{const{injectedWeb3:e}=window;return e?Object.keys(e):[]};export{X as connectInjectedExtension,q as getInjectedExtensions,J as getPolkadotSignerFromPjs};
